# [Gold IV] List of Unique Numbers - 13144 

[문제 링크](https://www.acmicpc.net/problem/13144) 

### 성능 요약

메모리: 2508 KB, 시간: 48 ms

### 분류

두 포인터

### 문제 설명

<p>길이가 N인 수열이 주어질 때, 수열에서 연속한 1개 이상의 수를 뽑았을 때 같은 수가 여러 번 등장하지 않는 경우의 수를 구하는 프로그램을 작성하여라.</p>

### 입력 

 <p>첫 번째 줄에는 수열의 길이 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>두 번째 줄에는 수열을 나타내는 N개의 정수가 주어진다. 수열에 나타나는 수는 모두 1 이상 100,000 이하이다.</p>

### 출력 

 <p>조건을 만족하는 경우의 수를 출력한다.</p>

### 해설
 <p>이 문제는 오랜시간 고민했지만 아이디어를 떠올리지 못했다. n이 10만이라서 n제곱에 비례하는 알고리즘으로는 절대 풀수없다. 그래서 투포인터로 풀어야 한다고 생각은 했지만, 어떻게 풀어야 한다고는 전혀 생각하지 못했다. 처음에는 구간을 정하는 걸 투포인터로 구하고, 그 구간안에서 중복이 몇개있는지 어떻게 구해야 하지 생각해는데, 애초에 구간 정하는거부터 N^2라서 불가능하다. 그리고 중복이 몇개있는지 구하는 알고리즘도 최소 logN이라서 불가능하다고 생각했다. 이 문제는 visited배열을 이용해서 그 전에 나왔는지 체크한다. 일단 투 포인터는 무조건 O(2N)에 끝내는 알고리즘이라는걸 생각하고 s, e가 끝점을 향해 단한번만 달려가는 걸 이용해서 풀어야 한다는 걸 명심해야 한다. 
1. s, e를 통해 늘려나가다면서 visited 배열에 True를 체크한다. 
2. visited[arr[e]]가 true라면 "지금까지 진행된 구간"에서 중복되는 번호가 나왔다는 뜻이므로, while문에서 탈출해서 차를 ans 변수에 넣어주고 s를 한칸 전진하면서 visited[arr[s]]를 false로 바꿔준다.
3. 여기서 중요한데, arr[e]가 방문했는지를 체크해야 한다. 왜냐하면 arr[s]로 2단계에서 false로 바꿔주기 때문에 만약 arr[e]가 true라면 아직도 중복된 변수가 구간사이에 있다는 의미이므로 바로 차를 계산해서 ans 변수에 넣어준다.
4. 만약 arr[e]가 false라면 arr[s]를 false로 바꿔주고 s를 전진시킨 구간에서 중복된 변수가 없다는 뜻이다. 
 </p>

